.. note::
    :class: sphx-glr-download-link-note

    Click :ref:`here <sphx_glr_download_auto_examples_tutorials_tuto_plot_custom_emissivity.py>` to download the full example code
.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_tutorials_tuto_plot_custom_emissivity.py:


Computing a camera image with custom emissivity
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This tutorial defines an emissivity that varies in space and computes the
signal received by a camera using this emissivity.

We start by loading a built-in `tofu` configuration and define a 2D camera.


.. code-block:: default


    import matplotlib.pyplot as plt
    import numpy as np
    import tofu as tf

    configB2 = tf.load_config("B2")

    cam2d = tf.geom.utils.create_CamLOS2D(
        config=configB2,
        pinhole=[3.4, 0, 0],
        sensor_nb=100,
        focal=0.1,
        sensor_size=0.1,
        orientation=[np.pi, np.pi/6, 0],
        Name="",
        Exp="",
        Diag="",
    )





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    /home/mendoza/miniconda3/envs/tofu3/lib/python3.7/site-packages/numpy/core/_asarray.py:102: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.
      return array(a, dtype, copy=False, order=order)




Now, we define an emissivity function that depends on r and z coordinates.
We can plot its profile in the (0, X, Z) plane.


.. code-block:: default



    def emissivity(pts, t=None, vect=None):
        """Custom emissivity as a function of geometry.

        :param pts: ndarray of shape (3, npts) (each column is a xyz coordinate)
        :param t: optional, time parameter to add a time dependency to the
            emissivity function
        :param vect: optional, ndarray of shape (3, npts), if anisotropic
            emissivity, unit direction vectors (X,Y,Z)
        :return:
            - emissivity -- 2D array holding the emissivity for each point in the
                input grid
        """
        r, z = np.hypot(pts[0, :], pts[1, :]), pts[2, :]
        e = np.exp(-(r - 2.4) ** 2 / 0.2 ** 2 - z ** 2 / 0.4 ** 2)
        if t is not None:
            e = np.cos(np.atleast_1d(t))[:, None] * e[None, :]
        else:
            # as stated in documentation of calc_signal, e.ndim must be 2
            e = np.reshape(e, (1, -1))
        return e


    y = np.linspace(2, 3, num=90)
    z = np.linspace(-0.5, 0.5, num=100)
    Y, Z = np.meshgrid(y, z)
    X = np.zeros_like(Y)
    pts = np.c_[X.ravel(), Y.ravel(), Z.ravel()].T
    emissivity_vals = emissivity(pts)
    emissivity_vals = emissivity_vals.reshape(X.shape)


    def project_to_2D(xyz):
        """Projection to (0, X, Z) plane."""
        return xyz[0], xyz[2]


    fig, ax = plt.subplots()
    ax.pcolormesh(Y, Z, emissivity_vals)
    ax.set_xlabel('y')
    ax.set_ylabel('z')
    configB2.plot(lax=ax, proj='cross')
    cam_center, = ax.plot(*project_to_2D(cam2d._dgeom['pinhole']), '*', ms=20)
    ax.set_aspect("equal")
    ax.legend(handles=[cam_center], labels=['camera pinhole'], loc='upper right')




.. image:: /auto_examples/tutorials/images/sphx_glr_tuto_plot_custom_emissivity_001.png
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    <matplotlib.legend.Legend object at 0x7fc919c5a4e0>



Finally, we compute an image using the 2D camera and this emissivity.
If we provide a time vector, the field will vary in a cosinusoidal fashion
(see above definition) across time.


.. code-block:: default


    time_vector = np.linspace(0, 2 * np.pi, num=100)

    sig, units = cam2d.calc_signal(emissivity,
                                   res=0.01,
                                   reflections=False,
                                   minimize="hybrid",
                                   method="sum",
                                   newcalc=True,
                                   plot=False,
                                   ani=False,
                                   t=time_vector)

    sig.plot(ntMax=1)
    plt.show(block=False)



.. image:: /auto_examples/tutorials/images/sphx_glr_tuto_plot_custom_emissivity_002.png
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    No handles with labels found to put in legend.
    /home/mendoza/tofu/tofu/utils.py:3476: UserWarning: Not interactive backend!:
        - backend : agg   (prefer Qt5Agg)
        - canvas  : FigureCanvasAgg
      warnings.warn(msg)
    /home/mendoza/miniconda3/envs/tofu3/lib/python3.7/site-packages/matplotlib/figure.py:445: UserWarning: Matplotlib is currently using agg, which is a non-GUI backend, so cannot show the figure.
      % get_backend())





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  2.438 seconds)


.. _sphx_glr_download_auto_examples_tutorials_tuto_plot_custom_emissivity.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download

     :download:`Download Python source code: tuto_plot_custom_emissivity.py <tuto_plot_custom_emissivity.py>`



  .. container:: sphx-glr-download

     :download:`Download Jupyter notebook: tuto_plot_custom_emissivity.ipynb <tuto_plot_custom_emissivity.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
